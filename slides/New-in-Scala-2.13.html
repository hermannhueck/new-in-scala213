<!DOCTYPE html>
<html>

<head>
  <title>What's new in Scala 2.13?</title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="keywords" content="Scala 2.13">
  <meta name="description" content="What's new in Scala 2.13?">

  <style type="text/css">
    @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
    @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
    @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

    body {
      font-family: 'Droid Serif';
    }

    h1,
    h2,
    h3 {
      font-family: 'Yanone Kaffeesatz';
      font-weight: 400;
      margin-bottom: 0;
    }

    .remark-slide-content h1 {
      font-size: 4em;
    }

    .remark-slide-content h2 {
      font-size: 2.5em;
    }

    .remark-slide-content h3 {
      font-size: 1.6em;
    }

    .footnote {
      position: absolute;
      bottom: 4em;
    }

    .footnote2 {
      position: absolute;
      bottom: 2em;
    }

    li p {
      line-height: 1.25em;
    }

    .red {
      color: #fa0000;
    }

    .large {
      font-size: 2em;
    }

    a,
    a>code {
      color: rgb(249, 38, 114);
      text-decoration: none;
    }

    code {
      background: #e7e8e2;
      border-radius: 5px;
    }

    .remark-code,
    .remark-inline-code {
      font-family: 'Ubuntu Mono';
    }

    .remark-code-line-highlighted {
      background-color: #373832;
    }

    .pull-left {
      float: left;
      width: 47%;
    }

    .pull-right {
      float: right;
      width: 47%;
    }

    .pull-right~p {
      clear: both;
    }

    #slideshow .slide .content code {
      font-size: 0.8em;
    }

    #slideshow .slide .content pre code {
      font-size: 0.9em;
      padding: 15px;
    }

    .inverse {
      background: #012908ec;
      color: #f3f3f3;
      text-shadow: 0 0 20px #333;
    }

    .inverse h1,
    .inverse h2 {
      color: #f3f3f3;
      line-height: 0.8em;
    }

    /* Slide-specific styling */
    #slide-inverse .footnote {
      bottom: 12px;
      left: 20px;
    }

    #slide-how .slides {
      font-size: 0.9em;
      position: absolute;
      top: 151px;
      right: 140px;
    }

    #slide-how .slides h3 {
      margin-top: 0.2em;
    }

    #slide-how .slides .first,
    #slide-how .slides .second {
      padding: 1px 20px;
      height: 90px;
      width: 120px;
      -moz-box-shadow: 0 0 10px #777;
      -webkit-box-shadow: 0 0 10px #777;
      box-shadow: 0 0 10px #777;
    }

    #slide-how .slides .first {
      background: #fff;
      position: absolute;
      top: 20%;
      left: 20%;
      z-index: 1;
    }

    #slide-how .slides .second {
      position: relative;
      background: #fff;
      z-index: 0;
    }

    /* Two-column layout */
    .left-column {
      color: #777;
      width: 20%;
      height: 92%;
      float: left;
    }

    .left-column h2:last-of-type,
    .left-column h3:last-child {
      color: #000;
    }

    .right-column {
      width: 75%;
      float: right;
      padding-top: 1em;
    }

    /* Two-column layout 50/50 */
    .left-column-50 {
      width: 49%;
      float: left;
    }

    .right-column-50 {
      width: 49%;
      float: right;
    }

    .micro-font {
      font-size: 0.5em
    }

    .mini-font {
      font-size: 0.75em
    }

    .small-font {
      font-size: 1em
    }

    .medium-font {
      font-size: 1.25em
    }

    .large-font {
      font-size: 1.5em
    }

    .xlarge-font {
      font-size: 1.75em
    }

    table {
      font-family: arial, sans-serif;
      border-collapse: collapse;
      width: 100%;
    }

    td,
    th {
      border: 1px solid #dddddd;
      text-align: left;
      padding: 8px;
    }

    tr:nth-child(0) {
      background-color: #dddddd;
    }
  </style>
</head>

<body>

  <textarea id="source">

name: main-template
layout: true
class: left, top, inverse

---

class: center

<br/>
<br/>
<br/>
# What's new in Scala 2.13?

<br/>
<br/>
<br/>
<br/>
### &copy; 2019 Hermann Hueck
<br/>
https://github.com/hermannhueck/new-in-scala213

---

<br/>
# Abstract

<br/>
<br/>
This presentation shows the feature updates from Scala 2.12 to 2.13.
The list of features is not comprehensive, but it is my personal selection of favorites.
I will focus on those which IMO impact/ease the programmers live most.

I will look at 5 feature areas: compiler, standard library, language changes,
Future and finally the most important change the redesigned collections library.

I will not only show the new features of 2.13. In many cases I will show how the
new features of 2.13 can be backported to 2.12 und be used in mostly the same way as in 2.13.

Finally I'll give some guide lines for the migration from 2.12 to 2.13 and for a cross version
project which compiles a code base with both compiler versions.

---

<br/>
# Agenda

<br/>
<br/>
1. [Release Summary](#release_summary)
1. [Compiler](#compiler)
1. [sbt Setup for Cross Compilation](#sbt_setup)
1. [Standard Library](#standard_library)
1. [Concurrency / Future](#concurrency_future)
1. [Language Changes](#language_changes)
1. [Collections](#collections)
1. [Architecture of Collections](#architecture_collections)
1. [Migration](#migration)
1. [Resources](#resources)

---

class: middle, center
name: release_summary

# 1. Release Summary
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

<br/>
## Release Summary

<br/>
Release 2.13 improves Scala in the following areas:

- <u>Collections</u>: Standard library collections have been overhauled for simplicity, performance, and safety.
  This is the centerpiece of the release.

--

- <u>Future</u>: is faster and more robust. 

--

- <u>Standard library</u>: New classes have been added and new methods enhance existing classes.
  But also some deprecations.

--

- <u>Language</u>: Literal types, partial unification is default, by-name implicits, more.

--

- <u>Compiler</u>: 5-10% faster, deterministic output, improved optimizer.

--

.footnote[
  Scala 2.13.0: &nbsp; https://github.com/scala/scala/releases/tag/v2.13.0
]
.footnote2[
  Scala 2.13.1: &nbsp; https://github.com/scala/scala/releases/tag/v2.13.1
]

---

class: middle, center
name: compiler

# 2. Compiler
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

<br/>
## Compiler

<br/>
- ###Performance improved

- ###Some improvments already flew back into 2.12.8, 2.12.9, 2.12.10.

- ###Deterministic, reproducible compilation

- ###Optimizer improvements (collections, arrays, inlining)

---

class: middle, center
name: sbt_setup

# 3. sbt Setup for Cross Compilation
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Cross compile with sbt
<br/>

```scala
// build.sbt

inThisBuild(
  Seq(
    scalaVersion := "2.13.1",
    crossScalaVersions := List("2.12.10", "2.13.1"),
    ...
  )
)
```

--

```scala
  scalacOptions ++= {
    CrossVersion.partialVersion(scalaVersion.value) match {
      case Some((2, minor)) if minor >= 13 =>
      Seq.empty
    case _ =>
      Seq(
        "-Ypartial-unification", // (removed in scala 2.13) allow the Compiler to
                                 // unify type constructors of different arities
        "-language:higherKinds", // (not required since scala 2.13.1) suppress
                                 // warnings when using higher kinded types
      )
    }
  }
```

---

class: middle, center
name: standard_library

# 3. Standard Library
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

<br/>
## Smaller Footprint
<br/>

###No longer included in the stdlib:

- ###*scala-parallel-collections*

- ###*scala-xml*

- ###*scala-parser-combinators*

- ###*scala-swing*

<br/>
These become libraries of their own.

---

<br/>
<br/>
## Integrated Java Interop
<br/>

- The old *scala-java8-compat* &nbsp;module is now part of the standard library.

- This provides converters for options, function types and Java streams.

- *scala.collection.JavaConversions* removed (already deprecated in 2.12).

---

## Chaining: *pipe* &nbsp;and *tap*

<br/>
```scala
import scala.util.chaining._

val x: Int = 5 tap println

val y: Int = 5 pipe (_ * x) tap println

List(1, 2, 3) pipe (ys => println("debug: " + ys.toString))

val times6 = (_: Int) * 6
(1 - 2 - 3)
  .tap(v => println(s"initial: $v"))
  .pipe(times6)
  .tap(v => println(s"after times6: $v"))
  .pipe(scala.math.abs)
  .pipe(v => println(s"after scala.math.abs: $v"))
```

--

<br/>
*x pipe f* is a replacement for *f(x)*, where f is a *Function1[A => B]*.

*x tap f* is a replacement for *x => { f(x)*; x }, where f is a side-effecting *Function1[A => Unit]*.
*tap* performs the side effect in *f(x)* and returns *x* unchanged.

---

<br/>
## Backport to 2.12: *pipe* &nbsp;and *tap*

<br/>
- My 2.12 backport library uses the same package name as in 2.13 stdlib: *scala.util.chaining*

```scala
package scala.util

package object chaining {

  implicit class ChainingOps[A](private val a: A) {

    @inline def pipe[B](f: A => B): B   = f(a)
    @inline def tap[B](f: A => Unit): A = { f(a); a }
  }
}
```

--

<br/>
<br/>
With this backport he same code runs without friction under 2.12 and 2.13.

---

<br/>
## Either: *Right.withLeft* &nbsp;and *Left.withRight*
<br/>

- *Right.apply* leaves the left type unspecified.<br/>
- *Left.apply* leaves the right type unspecified.
- *Right.withLeft* &nbsp;and *Left.withRight* let you specity the unspecified type.

--

```html
sbt:New in Scala 2.13> ++2.13.0 console
...
Welcome to Scala 2.13.0 ...

scala> Right(5)
res0: scala.util.Right[Nothing,Int] = Right(5)

scala> Right(5).withLeft[String]
res1: scala.util.Either[String,Int] = Right(5)

scala> Left("some error")
res2: scala.util.Left[String,Nothing] = Left(some error)

scala> Left("some error").withRight[Int]
res3: scala.util.Either[String,Int] = Left(some error)
```

---

<br/>
<br/>
## Backport to 2.12:<br/>*Right.withLeft* &nbsp;and *Left.withRight*
<br/>

```scala
package compat213

package object either {

  implicit class RightOps[L, R](private val right: Right[L, R]) {
    @inline def withLeft[LL >: L]: Either[LL, R] = right
  }

  implicit class LeftOps[L, R](private val left: Left[L, R]) {
    @inline def withRight[RR >: R]: Either[L, RR] = left
  }
}
```

---

## *Either#flatten*
<br/>

- available since 2.13

- *Either#flatten* is equivalent to *Either#flatMap(x => x)*

--

.left-column-50[

### Scala 2.12

```scala
val rr = Right(Right(42))
rr.flatMap(x => x) //=> Right(42)

val rl = Right(Left("Error RL"))
rl.flatMap(x => x) //=> Left("Error RL")

val l = Left("Error L")
l.flatMap(x => x) //=> Left("Error L")

val ll = Left(Left("Error LL"))
ll.flatMap(x => x) //=> Left(Left("Error LL"))
```
]

.right-column-50[

### Scala 2.13

```scala
val rr = Right(Right(42))
rr.flatten //=> Right(42)

val rl = Right(Left("Error RL"))
rl.flatten //=> Left("Error RL")

val l = Left("Error L")
l.flatten //=> Left("Error L")

val ll = Left(Left("Error LL"))
ll.flatten //=> Left(Left("Error LL"))
```
]

.footnote2[
  [scaladoc: Either](https://www.scala-lang.org/api/current/scala/util/Either.html)
]

---

<br/>
<br/>
## Backport to 2.12: &nbsp; *Either#flatten*
<br/>
<br/>

```scala
package compat213

package object either {

  implicit class EitherOps[+L, +R](private val either: Either[L, R]) {

    @inline def flatten[L1 >: L, RR](
        implicit ev: R <:< Either[L1, RR]
    ): Either[L1, RR] =
      either.flatMap(x => x)
  }
}
```

---

<br/>
## String Operations: *toIntOption* &nbsp;etc.
<br/>

- convert *String* literals to *Int*, *Double*, *Boolean* without throwing exceptions
- return *Some(value)* if the conversion succeeds, *None* if it fails.

--

<br/>
```html
sbt:New in Scala 2.13> ++2.13.0 console
...
Welcome to Scala 2.13.0 ...

scala> "42".toIntOption
res0: Option[Int] = Some(42)

scala> "42.0".toIntOption
res1: Option[Int] = None

scala> "42.0".toDoubleOption
res2: Option[Double] = Some(42.0)

scala> "true".toBooleanOption
res3: Option[Boolean] = Some(true)
```

---

<br/>
<br/>
## Backport to 2.12: String Operations
<br/>

```scala
package compat213

package object string {
  
  implicit class StringOps(private val s: String) {
    
    import scala.util.Try
    
    @inline def toIntOption: Option[Int]         = Try(s.toInt).toOption
    @inline def toDoubleOption: Option[Double]   = Try(s.toDouble).toOption
    @inline def toBooleanOption: Option[Boolean] = Try(s.toBoolean).toOption
  }
}
```

---

## *scala.util.Using.apply* &nbsp;for resource management
<br/>

Similar to *try ... catch ... finally*,<br/>
but guarantees to release/close the used resource.

--

<br/>
```scala
def bufferedReader(fileName: String): BufferedReader =
  new BufferedReader(new FileReader(fileName))

def readLines(reader: BufferedReader): Seq[String] =
  ??? // some impl

def tryLines(fileName: String): Try[Seq[String]] =
  Using(bufferedReader(fileName)) { reader => readLines(reader) }

def catFile(fileName: String): Unit =
  tryLines(fileName) match {
    case Failure(exception) => exception.toString pipe println
    case Success(lines) => lines foreach println
  }

catFile("README.md")
```

---

## *scala.util.Using.resource*
<br/>
returns an *A*, not a *Try[A]*

--

```scala
package scala.util
object Using { // simplified
  def apply[R, A](resource: => R)(f: R => A): Try[A]
  def resource[R, A](resource: => R)(f: R => A): A
  ...
}
```

--

<br/>
```scala
def bufferedReader(fileName: String): BufferedReader = ???

def readLines(reader: BufferedReader): Seq[String] = ???

def lines(fileName: String): Seq[String] =
  Using.resource(bufferedReader(fileName))(readLines)

def catFile2(fileName: String): Unit = { // might throw an exception
  lines(fileName) foreach println
}

catFile2("README.md")
```

---

## Backport to 2.12: *Using*
<br/>

```scala
package compat213

import scala.util.Try
import scala.language.reflectiveCalls

object Using {

  type Closable = { def close(): Unit }

  def apply[A, R <: Closable](resrc: R)(use: R => A): Try[A] =
    Try(resource(resrc)(use))

  def resource[A, R <: Closable](resrc: R)(use: R => A): A =
    try {
      use(resrc)
    } finally {
      resrc.close()
    }
}
```

--

<br/>
This impl is a bit simplistic, but should work for resources which provide a method *close*.

---

<br/>
<br/>
## s-Interpolator in Pattern matches
<br/>

<br/>
```scala
val dateString = "11-June-2019"

val s"$day-$month-$year" = dateString

year pipe println
month pipe println
day pipe println
```

---

## Named Product Elements

### *Product*s (i.e. case classes and Tuples) now have methods *productElementNames* &nbsp;and &nbsp;*productElementName*.

--
<br/>
```scala
sealed trait Gender extends Product with Serializable
case object Male extends Gender
case object Female extends Gender

case class Person(name: String, age: Int, gender: Gender, email: String) {
  def tupled: (String, Int, Gender, String) = Person.unapply(this).get
}

val johndoe = Person("John Doe", 42, Male, "john@doe.com")
```
--

<br/>
```scala
johndoe.productElementNames foreach println

johndoe.productElementName(0) pipe (name => print(s"$name: "))
johndoe.productElement(0) pipe println
johndoe.productElementName(1) pipe (name => print(s"$name: "))
johndoe.productElement(1) pipe println
```

---

## Named Product Elements

<br/>
### Naive JSON Serialization

```scala
def pairToJson(name: String, value: Any): String =
  s"""{ "$name": $value }"""

def productElementToJson(p: Product, index: Int): String =
  pairToJson(p.productElementName(index), p.productElement(index))

def productToJson(product: Product): String =
  (0 until product.productArity)
    .toList
    .map { index => productElementToJson(product, index) }
    .mkString("{ ", ", ", " }")

implicit class ProductOps(private val product: Product) {
  def toJsonString: String = productToJson(product)
}

johndoe.toJsonString pipe println
// { { "name": John Doe }, { "age": 42 }, { "gender": Male }, { "email": john@doe.com } }
johndoe.tupled.toJsonString pipe println
// { { "_1": John Doe }, { "_2": 42 }, { "_3": Male }, { "_4": john@doe.com } }
```

---

class: middle, center
name: concurrency_future

# 4. Concurrency / Future
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

<br/>
## *Future* + *ExecutionContext* &nbsp;Changes Overview
<br/>

- API nearly unchanged

- Massive performance improvements under the hood (*Future*, *Promise*, *ExecutionContext*)

- Improved handling of failures (*InterruptedException, RejectedExecutionException*)

- Made the global *ExecutionContext* “batched”

- Added synchronous ("parasitic") *ExecutionContext*
  (releases you from writing your own synchronous *ExecutionContext*)

.footnote[
  For more details on the internals of the improved implementation
  see Viktor Klang's talk at Scala Days 2019: Making Our Future Better
]
.footnote2[
  https://www.youtube.com/watch?v=5FTJUUoT6y4
]

---

<br/>
<br/>
## *Future* : Minor API Changes
<br/>
<br/>

- *removed *onSuccess* and *onFailure* (already deprecated in 2.12)

- *Future.delegate* - new factory method

---

<br/>
## *Future.delegate*
<br/>

```scala
object Future {
  def apply[T](body: => T)(implicit executor: ExecutionContext): Future[T]
  def delegate[T](body: => Future[T])(implicit executor: ExecutionContext): Future[T]
  ...
}
```

--

<br/>
The following expressions are semantically equivalent:

```scala
  def expr[T]: Future[T] = ???

  val f1 = Future.delegate(expr)
  val f2 = Future.apply(expr).flatten
  val f3 = Future.unit.flatMap(_ => expr)
```

---

<br/>
## *Future.delegate* - Example
<br/>

```scala
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.chaining._

implicit lazy val ec: ExecutionContext = ExecutionContext.global

def plus17(x: Int): Int = x + 17

def squaredAsync(value: Int) = Future { value * value }

val f1: Future[Int] = Future.apply { squaredAsync(5) }.flatten map plus17
val f2: Future[Int] = Future.unit.flatMap { _ => squaredAsync(5) } map plus17
val f3: Future[Int] = Future.delegate { squaredAsync(5) } map plus17

Await.result(f1, 3.seconds) pipe println   //=> 42
Await.result(f2, 3.seconds) pipe println   //=> 42
Await.result(f3, 3.seconds) pipe println   //=> 42
```

---

class: middle, center
name: language_changes

# 5. Language Changes
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Language Changes Overview

- Literal types: Literals (for strings, integers etc.) now have associated literal types.

- Partial unification: enabled by default

- By-name implicit parameters: enable implicit search to construct recursive values.

- Underscores in numeric literals

- Procedure syntax deprecated:<br/>
  Deprecated: *def m() { ... }* &nbsp; &nbsp; &nbsp; Use instead: *def m(): Unit = { ... }*

- View bounds deprecated:<br/>
  Deprecated: *A &lt;% B* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Use instead: *(implicit ev: A => B)*

- Symbol literals deprecated:<br/>
  Deprecated: *'foo* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Use instead: *Symbol("foo")*

- New Tuple2 arrow syntax in pattern match:<br/>
  2.12 and 2.13: &nbsp; *case (x, y) => ...*<br/>
  2.13 only &nbsp; &nbsp; &nbsp; : &nbsp; *case x -> y => ...*

---

<br/>
## Underscores in Number Literals
<br/>
<br/>

```scala
val int0: Int = 1000000
val int1: Int = 1_000_000
val int2: Int = 1_0_0_0_0_0_0

// val int3: Int = 1_0_0_0_0_0_0_
// compile error: trailing separator is not allowed

val long: Long = 1_000_000_000L
val float: Float = 1_000.99f
val double: Double = 1_000_000.999_999
```

---

## Partial unification

<br/>
- Partial unification is enabled by default in 2.13.
- The compiler no longer accepts *-Ypartial-unification*.
- The following code compiles in 2.12 only with *-Ypartial-unification*.

--

<br/>
```scala
// import scala.language.higherKinds // redundant since 2.13.1

def foo[F[_], A](fa: F[A]): String =
  fa.toString

val either: Either[String, Int] = Right(42).withLeft[String]
foo { either }

val intToInt: Function1[Int, Int] = x => x * 2
foo { intToInt }
```

--

<br/>
Detailed explanation of partial unification here:<br/>
https://gist.github.com/djspiewak/7a81a395c461fd3a09a6941d4cd040f2

---

<br/>
<br/>
### *scalacOptions* in *build.sbt* &nbsp;for cross compilation
<br/>
<br/>

```scala
scalacOptions ++= {
  CrossVersion.partialVersion(scalaVersion.value) match {
    case Some((2, minor)) if minor >= 13 =>
      Seq.empty
    case _ =>
      Seq(
        "-Ypartial-unification", // (removed in scala 2.13) allow the Compiler to
                                 // unify type constructors of different arities
        "-language:higherKinds"  // (not required since scala 2.13.1) suppress
                                 // warnings when using higher kinded types
      )
  }
}
```

---

<br/>
## Literal Types

<br/>
- Literals (for strings, integers etc.) now have associated literal types.
- The compiler will provide instances of a new typeclass *scala.ValueOf\[T]* for all singleton types *T*.
- The value of a singleton type can be accessed by calling method *valueOf[T]*.

--

<br/>
```scala
val wahr: true = true

val foo: "foo" = "foo"

val one: 1 = 1

val other_one: one.type = one
implicitly[other_one.type =:= 1]

val x1: Int = valueOf[42] // valueOf[42] yields an Int and is the same as ...
val x2: Int = new scala.ValueOf(42).value
```

---

<br/>
## By-name Implicit Parameters

<br/>
- were not allowed in 2.12.
- They enable implicit search to construct recursive values.
- The following code will not compile<br/>
  if you remove the &nbsp; *=>* &nbsp; in &nbsp; *(implicit rec: => Foo)* &nbsp; .

--

<br/>
```scala
trait Foo {
  def next: Foo
}

object Foo {
  // wouldn't compile, if rec were a call by value parameter
  // remove the => and try to compile ...
  implicit def foo(implicit rec: => Foo): Foo =
    new Foo { def next = rec }
}

val foo = implicitly[Foo]
assert(foo eq foo.next)
```

---

class: middle, center
name: collections

# 6. Collections
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

<br/>
<br/>
## Principles of the Collections Redesign
<br/>
<br/>

- <u>simplicity</u>
  - better error messages
  - easier to implement your own collection (but still complex)

- <u>performance</u>

- <u>type safety</u>, better <u>type inference</u>

- <u>smaller footprint</u>: parallel collections moved to a module of it's own, etc.

- <u>source code compatibility</u> - as much as possible<br/>
  Most ordinary code that used the old collections will continue to work as-is.
  But of course ... there are <u>breaking changes</u>.

---

<br/>
## Simpler Method Signatures
<br/>

- No more *CanBuildFrom*

- Without *CanBuildFrom* method signatures became much simpler.

--

### *List#map* &nbsp;in 2.12

```scala
trait List[+A] extends ... {
  def map[B, That](f: A => B)(implicit bf: CanBuildFrom[List[A], B, That]): That = ???
}
```

### *List#map* &nbsp;in 2.13

```scala
trait List[+A] extends ... {
  def map[B](f: A => B): List[B] = ???
}
```

---

<br/>
<br/>
## Simpler Type Hierarchy
<br/>
<br/>


- No more *Traversable* and *TraversableOnce*.

  - They remain only as deprecated aliases for *Iterable* and *IterableOnce*.

<br/>
- Parallel collections are now a separate module.

  - As a result, *GenSeq*, *GenTraversableOnce*, et al. are gone.


---

<br/>
<br/>
## New, Faster HashMap/Set Implementations
<br/>
<br/>


- Both immutable and mutable versions were completely replaced.

- They substantially outperform the old implementations in most scenarios.

- The mutable versions now perform on par with the Java standard library's implementations.


---

<br/>
<br/>
## Immutable *scala.Seq* &nbsp;and *scala.IndexedSeq*
<br/>
<br/>


- *Seq* is now an alias for *collection.immutable.Seq*.
  - Before, it was an alias for the possibly-mutable *collection.Seq*.

- *IndexedSeq* is now an alias for *collection.immutable.IndexedSeq*.
  - Before, it was an alias for the possibly-mutable *collection.IndexedSeq*.

- This also changes the type of varargs in methods and pattern matches.

- Arrays passed as varargs are defensively copied.

---

<br/>
## *Seq* &nbsp;is immutable in 2.13 (not in 2.12)
<br/>

```scala
trait Order
trait Food

def orderFood(order: Seq[Order]): Seq[Food] = {
    Seq(new Food{})
}
```

--

<br/>
### Passing a mutable *ArrayBuffer* ...

```scala
// We can NOT pass a mutable ArrayBuffer where an immutable Seq is expected.
val food1 = orderFood(ArrayBuffer(new Order{})) // DOES NOT COMPILE!
//  [error]  found   : scala.collection.mutable.ArrayBuffer[Order]
//  [error]  required: Seq[Order]
```

---

<br/>
### Passing a mutable *Array* ...
<br/>

We can pass a mutable *Array* where an immutable *Seq* is expected.<br/>
*Array* (unlike *ArrayBuffer*) is implicitly converted (and copied).<br/> 
But the compiler spits out a warning.

```scala
val orderArray = Array(new Order {})

val food2 = orderFood(orderArray)     // COMPILES WITH WARNING!
// [warn] Implicit conversions from Array to immutable.IndexedSeq
// [warn] are implemented by copying; Use the more efficient non-copying
// [warn] ArraySeq.unsafeWrapArray or an explicit toIndexedSeq call.
```

--

<br/>
*toSeq* (or *toIndexedSeq*) wraps the mutable *Array* in an immutable *Seq*.

```scala
val food3 = orderFood(orderArray.toSeq)           // COMPILES!
val food4 = orderFood(orderArray.toIndexedSeq)    // COMPILES!
```

---

<br/>
### Passing a immutable *ArraySeq* ...
<br/>

- *ArraySeq* is a new collection of Scala 2.13.

- *ArraySeq* is an immutable array with efficient indexed access and a small memory footprint.

- *mutable.ArraySeq* is also available in the new collections library.

- For Scala 2.12 an *ArraySeq* backport is provided in the *scala-collection-compat* library.

- *ArraySeq.unsafeWrapArray* wraps an *Array* in an *ArraySeq*.

<br/>
```scala
val food5 = orderFood(ArraySeq(new Order{}))
val food6 = orderFood(ArraySeq.unsafeWrapArray(Array(new Order{})))
```

---

<br/>
## Cross-compiling *Seq* &nbsp;for 2.12 and 2.13
<br/>

### Seq Recap

- *scala.collection.Seq* is a base class for *scala.collection.immutable.Seq* and *scala.collection.mutable.Seq* in Scala 2.12 and 2.13.

- *scala.Seq* is an alias for *scala.collection.Seq* in Scala 2.12.

- *scala.Seq* is an alias for *scala.collection.immutable.Seq* in Scala 2.13.

--

<br/>
<br/>
To make your 2.12 code cross-compilable for 2.12 and 2.13 you have

### 3 Options described below ...

---

## Cross-compiling *Seq* &nbsp;(1st option)
<br/>

### Explicitly use *scala.collection.Seq* &nbsp;in method parameters and return types.

```scala
import scala.collection

def orderFood(order: collection.Seq[Order]): collection.Seq[Food] = ???
```

--

<br/>
- You don't force your code into immutable semantics.
- *orderFood* accepts mutable and immutable *Seq*s.
- mutability / immutability is unspecified for the return type.
- Caller must call *.toSeq* if she only needs an immutable result.
  (*.toSeq* only copies elements if the result is not yet immutable.)

### Simplest migration strategy!
### No changes at the call site!

---

## Cross-compiling *Seq* &nbsp;(2nd option)
<br/>

### Explicitly use *scala.collection.Seq* &nbsp;in parameters and *scala.collection.immutable.Seq* &nbsp; in return types.

```scala
import scala.collection
import scala.collection.immutable

def orderFood(order: collection.Seq[Order]): immutable.Seq[Food] = ???
```

--

<br/>
- You force your code into immutable semantics only for return types.
- *orderFood* accepts mutable and immutable *Seq*s.
- immutability is fixed for the return type.

### Still simple migration strategy!
### Mostly no changes at the call site!

---

## Cross-compiling *Seq* &nbsp;(3rd option)
<br/>

### Use *scala.immutable.collection.Seq* &nbsp;in method parameters and return types.

```scala
import scala.collection.immutable

def orderFood(order: immutable.Seq[Order]): immutable.Seq[Food] = ???
```

--

<br/>
- You force your code into immutable semantics.
- *orderFood* accepts only immutable *Seq*s.
- immutability is also fixed for the return type.

### Possibly many changes at the call site to make the arguments immutable!
### Use Scalafix to automate this rewrite for a large code base.

---

<br/>
<br/>
## Simplified Views that Work
<br/>
<br/>

- Views have been vastly simplified and should now work reliably.

- *scala.collection.View* has two sub classes: *scala.collection.SeqView* and *scala.collection.MapView*

- Views are lazy. They record the operations (like *filter*, *map* etc.) and do not execute them
  before invoking a terminal operation (*foreach*, *toSeq*, *toMap* etc.).

---

## *Map#mapValues* &nbsp;and *Map#filterKeys*

- *Map#mapValues* and *Map#filterKeys* in 2.13 return *MapView*, not *Map*.

- These methods are also deprecated.

- Prefer using *MapView#mapValues* and *MapView#filterKeys*

--

```scala
val kvs = Map("one" -> 1, "two" -> 2, "three" -> 3)
def flip[A, B](t: (A, B)): (B, A) = t match { case (fst, snd) => (snd, fst) }
val kvsFlipped: Map[Int, String] = kvs.toList.map(flip).toMap
```

.left-column-50[

### Scala 2.12

```scala


val mappedValues: Map[String, Int] =
  kvs.mapValues(_ + 10)



val keysFiltered: Map[Int, String] =
  kvsFlipped.filterKeys(_ %2 != 0)
```
]

.right-column-50[

### Scala 2.13

```scala
val mapView: MapView[String, Int] =
  kvs.view.mapValues(_ + 10)
val mappedValues: Map[String, Int] =
  mapView.toMap

val mapView2: MapView[Int, String] =
  kvsFlipped.view.filterKeys(_ %2 != 0)
val keysFiltered: Map[Int, String] =
  mapView2.toMap
```
]

---

## *LazyList* &nbsp;replaces *Stream*
<br/>

- *Stream* is lazy in it's tail, but eager in it's head.

- *LazyList* is lazy in it's head and tail.

- *Stream* is deprecated in 2.13.
<br/>

.left-column-50[

### Scala 2.12

```scala
val stream: Stream[(Int, Int)] =
  Stream
    .continually(42)
    .take(10)
    .zipWithIndex
    .map { case (value, index) =>
      index -> value
    }
```
]

.right-column-50[

### Scala 2.13

```scala
val ll: LazyList[(Int, Int)] =
  LazyList
    .continually(42)
    .take(10)
    .zipWithIndex
    .map { case value -> index =>
      index -> value
    }
```
]

---

## New Abtract and Concrete Collections
<br/>

- *immutable.LazyList* replaces *immutable.Stream*.

- *immutable.ArraySeq* is an immutable wrapper for an array; there is also a mutable version.

- *mutable.CollisionProofHashMap* guards against denial-of-service attacks.

- *mutable.ArrayDeque* is a double-ended queue that internally uses a resizable circular buffer.

- *mutable.Stack* was reimplemented (and undeprecated), *immutable.Stack* was removed.

- *immutable.SeqMap* (abstract) provides immutable maps which maintain insertion order.

- Implementations: *VectorMap* and *TreeSeqMap* (in addition to the already existing *ListMap*)

---

## *Coll#to* &nbsp;converts one collection to another one.
<br/>

- *Coll#to* in 2.12 received the target type in square brackets.

- *Coll#to* in 2.13 receives the target type's companion in parens.

- The *scala-collection-compat* library provides the new behaviour in 2.12.

<br/>
```scala
val map = Map("one" -> 1, "two" -> 2, "three" -> 3)
```

.left-column-50[

### Scala 2.12

```scala
val l1 = map.toList
val l2 = map.to[List]

import scala.collection.compat._
val l3 = map.to(List)
```
]

.right-column-50[

### Scala 2.13

```scala
val l1 = map.toList
val l2 = map.to(List)


//
```
]

---

<br/>
<br/>
## Added *.lengthIs / .sizeIs* &nbsp;and *.sizeCompare*
<br/>
<br/>

- Allow fluent size comparisons without traversing the whole collection.

--

<br/>
```scala
val xs = List.fill(5000)(scala.util.Random.nextInt)

// lenghtIs or sizeIs traverse no more than 101 element
if (xs.lengthIs > 100) {
    new IllegalArgumentException("Too many elements!") pipe println
} else {
    s"The list has ${xs.length} elements." pipe println
}
```

---

<br/>
<br/>
## New *.tapEach* &nbsp;method for side-effects
<br/>
<br/>

- Allows inserting side-effects in a chain of method calls on a collection or view.

--

<br/>
```scala
val doubledAndSquared =
  List(1, 2, 3)
    .tapEach(x => println(s"value: $x"))
    .map(x => x * 2)
    .tapEach(x => println(s"doubled: $x"))
    .map(x => x * x)
    .tapEach(x => println(s"squared: $x"))
```

---

<br/>
## New method *List.unfold* &nbsp;or *Iterator.unfold*
<br/>
<br/>

- This allows constructing a collection or iterator from an initial element
  and a repeated *Option*-returning operation, terminating on *None*.

- This was added to collection companion objects and to *Iterator*.

--

<br/>
```scala
val unfoldFunction: Int => Option[(Int, Int)] = {
  case 0 => None
  case s => Some(((s * s), (s - 1)))
}

List.unfold(10)(unfoldFunction) pipe println
//=> List(100, 81, 64, 49, 36, 25, 16, 9, 4, 1)
```

---

<br/>
## Read Lines with *Iterator.unfold*
<br/>

```scala
def bufferedReader(fileName: String) =
  new BufferedReader(new FileReader(fileName))

def readLines(reader: BufferedReader) =
  Iterator.unfold(())(_ => Option(reader.readLine()).map(_ -> ())).toList

def readLines_dissected(reader: BufferedReader): List[String] = {
  val initialState: Unit = ()
  val iterator: Iterator[String] = Iterator.unfold(initialState) { _ =>
    val maybeLine: Option[String] = Option(reader.readLine())
    val maybeLineState: Option[(String, Unit)] = maybeLine.map(_ -> ())
    maybeLineState
  }
  iterator.toList
}

val lines: Seq[String] =
  Using.resource(bufferedReader("README.md"))(readLines)

lines foreach println
```

---

<br/>
## Backport to 2.12: *List.unfold*
<br/>

```scala
def unfoldToStream[A, B](init: A)(f: A => Option[(B, A)]): Stream[B] =
  f(init)
    .map {
      case (b, a) =>
        b #:: unfoldToStream(a)(f)
    }
    .getOrElse(Stream.empty)

def unfoldToList[A, B](init: A)(f: A => Option[(B, A)]): List[B] =
  unfoldToStream(init)(f).toList

implicit class ListCompanionOps(private val self: List.type) extends AnyVal {

  @inline def unfold[A, B](init: A)(f: A => Option[(B, A)]): List[B] =
    unfoldToList(init)(f)
}
```

---

## Removed *collection.breakOut*

- *collection.breakOut* in 2.12 inferred the return type of a collection operation from the expected result type.

- It was based on *CanBuildFrom* which is gone in 2.13.

- To avoid constructing intermediate collections, use *.view* and *.to(Collection)* instead.

--

```scala
val list = List(1, 2, 3) tap println
val toPair: Int => (Int, Int) = x => x -> x
```

```scala
// Scala 2.12 - type annotations required to infer the result type of list.map
val indexedSeq                      = list.map(toPair)(collection.breakOut)
val array   : Array[(Int, Int)]     = list.map(toPair)(collection.breakOut)
val seq     : Seq[(Int, Int)]       = list.map(toPair)(collection.breakOut)
val set     : Set[(Int, Int)]       = list.map(toPair)(collection.breakOut)
val map     : Map[Int, Int]         = list.map(toPair)(collection.breakOut)
```

```scala
// Scala 2.13 - type annotations not required
val list2                           = list.view.map(toPair).to(List)
val array                           = list.view.map(toPair).to(Array)
val seq                             = list.view.map(toPair).to(Seq)
val set                             = list.view.map(toPair).to(Set)
val map                             = list.view.map(toPair).to(Map)
```

---

<br/>
## Two overloaded *Map#map* &nbsp;operations! Why ???
<br/>

```scala
def map[K2, V2](f: ((K, V)) => (K2, V2)): Map[K2, V2]
```

```scala
def map[B](f: ((K, V)) => B): Iterable[B]
```

--

<br/>
- If the mapping function &nbsp;*f*&nbsp; transforms a key value pair *(K, V)* into another key value pair *(K2, V2)*,
  *map* returns a *Map[K2, V2]*.

- OTOH if the mapping function &nbsp;*f*&nbsp; transforms a key value pair *(K, V)* into some other value *B*,
  *map* returns a *Iterable[B]*.

- Roughly the same holds for the two *Map#flatMap* operations.

- To understand this we have to take a glimpse into the collections' architecture.

---

class: middle, center
name: architecture_collections

# 7. Architecture of Collections
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

.footnote[
  See also:
]
.footnote2[
  https://docs.scala-lang.org/overviews/core/architecture-of-scala-213-collections.html
]

---

## Problem to solve

### Define the return type of a collection operation in a generic way?

- This is not a problem for operations, which do not return a collection, but a single value
  like *isEmpty*, *length*, *find*, *foldLeft*, *sum*, *exists*, *forall* etc.
  
- This is difficult for operations that return a collection
  like *filter*, *take*, *drop*, *map*, *flatMap*, *flatten* etc.

--

<br/>
A Non-solution with simple inheritance:

```scala
trait Iterable[A] {
  def filter(f: A => Boolean): Iterable[A]
  def map[B](f: A => B): Iterable[B]
}
```

```scala
trait List[A] extends Iterable[A] { ... }
trait Vector[A] extends Iterable[A] { ... }
```

The inherited methods would return an *Iterable*, not a *List* or *Vector*.

---

<br/>
## What we need ...

```scala
trait List[A] extends MagicBaseTrait[???, ???, ???] {
  def filter(f: A => Boolean): List[A]
  def map[B](f: A => B): List[B]
}

trait Vector[A] extends MagicBaseTrait[???, ???, ???] {
  def filter(f: A => Boolean): Vector[A]
  def map[B](f: A => B): Vector[B]
}

trait Map[K, V] extends MagicBaseTrait[???, ???, ???] {
  def filter(f: (K, V) => Boolean): List[A]
  def map[K2, V2](f: (K, V) => (K2, V2)): Map[K2, V2]
  def map[B](f: (K, V) => B): Iterable[B]
}
```

... without being forced to reimplement the operations in every collection.

--

### In the old collection implementation (up to 2.12) this problem has been solved with *CanBuildFrom*.

---

<br/>
## Selections and Transformations
<br/>

- <u>Selection operations</u> (*filter*, *take*, *drop* etc.) do not change the elements.

  - The target type of the operation is exactly the same as the source type,<br/>
    e.g. *filter* on a *List[A]* returns a *List[A]*.
  - We must abstract over the source collection type (*List[A]*) in this case) to generalize this.

- <u>Transformation operations</u> (*map*, *flatMap* etc.) do change the elements
  and in some cases (*Map* and some others) also the collection type.

  - The target type of the operation must be derived
    from the type constructor of the required result collection type.

---

## *IterableOps*
<br/>

```scala
trait IterableOps[+A, +CC[_], +C] {
  def filter(p: A => Boolean): C = ???
  def map[B](f: A => B): CC[B] = ???
}
```

```scala
trait List[+A] extends Iterable[A] with IterableOps[A, List, List[A]] {...}
trait Vector[+A] extends Iterable[A] with IterableOps[A, Vector, Vector[A]] {...}
```

--

- *IterableOps* is the MagicBaseTrait we are looking for.

- *IterableOps* is called a template trait.

- *IterableOps* has 3 type parameters, one for the element type (*A*), one for the collection type (*C*)
  and one for the collection's type constructor type (*CC*).

- Leaf collection types with one type parameter (*List*, *Vector*) extend *IterableOps*.

- This does not work for collections like *Map* with two type parameters.

---

## *MapOps*
<br/>

```scala
trait MapOps[K, +V, +CC[_, _], +C] extends IterableOps[(K, V), Iterable, C] {
  def map[K2, V2](f: ((K, V)) => (K2, V2)): CC[K2, V2] = ???
}
```

```scala
trait Map[K, V] extends Iterable[(K, V)] with MapOps[K, V, Map, Map[K, V]]
```

--

<br/>
- *MapOps* extends *IterableOps* and hence inherits all its operations.

- *MapOps* instantiates the collection's type constructor *CC* with *Iterable*.

- *MapOps* inherits a *map* operation from *IterableOps* returning *Iterable[B]*.

- *MapOps* defines another *map* operation overload returning *Map[K2, V2]*.

- *Map* inherits both *map* operations.

---

## Which *map* &nbsp;is chosen ...

... when you invoke *Map#map* at the call site?

<br/>
```scala
// from IterableOps
def map[B](f: ((K, V)) => B): Iterable[B]

// from MapOps
def map[K2, V2](f: ((K, V)) => (K2, V2)): Map[K2, V2]
```

<br/>
- *map* from *MapOps* is more specific by the rules of overloading resolution.

- It will be chosen, if the *map* operation returns a pair of values.

- Otherwise the operation from *IterableOps* applies.

--

<br/>
<u>“same-result-type” principle</u>:<br/>
&nbsp; &nbsp; &nbsp; Wherever possible a transformation method on a collection<br/>
&nbsp; &nbsp; &nbsp; yields a collection of the same type.

---

class: middle, center
name: migration

# 8. Migration
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

.footnote[
  See also:
]
.footnote2[
  https://docs.scala-lang.org/overviews/core/collections-migration-213.html
]

---

<br/>
<br/>
## When to Migrate?
<br/>
<br/>

- ### when all *libraryDependencies* &nbsp;are availabe for 2.13.

- ### when all transitive dependencies are availabe for 2.13.

---

#### Scala 2.13 Library support (2019-09-19) <br/>

<table class="micro-font">
  <tr> <th><u>Library</u></th><th><u>Since</u></th><th><u>Current</u></th> </tr>
  <tr> <td>scalatest</td><td>3.0.8</td><td>3.0.8</td> </tr>
  <tr> <td>scalacheck</td><td>???</td><td>1.14.1-RC1</td> </tr>
  <tr> <td>specs2</td><td>4.6.0</td><td>4.7.1</td> </tr>
  <tr> <td>akka-*</td><td>2.5.23</td><td>2.5.25</td> </tr>
  <tr> <td>akka-http</td><td>10.1.8</td><td>10.1.9</td> </tr>
  <tr> <td>play</td><td>2.7.3</td><td>2.7.3</td> </tr>
  <tr> <td>slick</td><td>3.3.2</td><td>3.3.2</td> </tr>
  <tr> <td>lagom</td><td>???</td><td>1.6.0-M5</td> </tr>
  <tr> <td>kind-projector</td><td>0.10.3</td><td>0.10.3</td> </tr>
  <tr> <td>shapeless</td><td>2.3.3</td><td>2.3.3</td> </tr>
  <tr> <td>cats</td><td>2.0.0</td><td>2.0.0</td> </tr>
  <tr> <td>cats-effect</td><td>2.0.0</td><td>2.0.0</td> </tr>
  <tr> <td>fs2</td><td>2.0.0</td><td>2.0.0</td> </tr>
  <tr> <td>http4s</td><td>???</td><td>0.21.0-M4</td> </tr>
  <tr> <td>circe</td><td>0.12.0</td><td>0.12.1</td> </tr>
  <tr> <td>scalaz</td><td>7.2.27</td><td>7.2.28</td> </tr>
  <tr> <td>zio</td><td>???</td><td>1.0.0-RC12-1</td> </tr>
  <tr> <td>apache-spark</td><td>???</td><td>2.4.4 (only for 2.13)</td> </tr>
</table>

---

<br/>
## Before You Migrate ...
<br/>
<br/>

- Upgrade your project to the latest 2.12.x version.

- Remove all deprecation warnings. Turn warnings into errors: *scalacOptions += -Xfatal-warnings*

- Scalafix them if there are many. (Turn off *-Xfatal-warnings* while running scalafix. This option let's scalafix fail.)

- Upgrade your sbt *libraryDependencies* to versions which are available in both binary versions: 2.12 and 2.13.

---

<br/>
## Migrate an Application to 2.13
<br/>

(This project **must not cross compile**.)

<br/>
- Use *scalafix* to automate as much as possible!

- Rewrite the rest by hand.

- Use new features of 2.13.

- You loose backward compatibility to 2.12.

---

<br/>
## Migrate a Library to a Cross Compatible Version
<br/>

(This project **must cross compile**.)

<br/>
- Keep source compatibility as much as possible without using the new features of 2.13.

- Use version specific source folders: *src/main/scala-2.12* and *src/main/scala-2.13*

- Use *scala-collection-compat* library which backports many parts of the collection API to 2.12.

- Use *scalafix* to automate as much as possible!

- Rewrite the rest by hand.

---

<br/>
## Migration Automation with Scalafix (Setup)
<br/>
<br/>

--

Add scalafix plugin

```scala
// project/plugins.sbt
addSbtPlugin("ch.epfl.scala" % "sbt-scalafix" % "0.9.7")
```

--

Change *build.sbt*

```scala
// build.sbt
scalafixDependencies += "org.scala-lang.modules" %% "scala-collection-migrations" % "2.1.2"

// scala-collection-compat needed only for cross compilation
libraryDependencies += "org.scala-lang.modules" %% "scala-collection-compat" % "2.1.2"

scalacOptions -= "-Xfatal-warnings" // let's scalafix fail
scalacOptions ++= List("-Yrangepos", "-P:semanticdb:synthetics:on")
```

---

<br/>
## Migration Automation with Scalafix (Run)
<br/>
<br/>

Run scalafix in sbt shell (for upgrade to 2.13)

```scala
> ;test:scalafix Collection213Upgrade ;scalafix Collection213Upgrade
```

Run scalafix in sbt shell (for cross compilation with 2.12 and 2.13)

```scala
> ;test:scalafix Collection213CrossCompat ;scalafix Collection213CrossCompat
```

.footnote[
Scala 2.13 Collection Compatibility Library and Migration Tool:
]
.footnote2[
https://github.com/scala/scala-collection-compat
]

---

class: middle, center
name: resources

# 21. Resources
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Resources

- Code and Slides of this Talk:<br/>
  https://github.com/hermannhueck/new-in-scala213

- Official Release Description<br/>
  https://github.com/scala/scala/releases/tag/v2.13.0

- Making Our Future Better<br/>
  Viktor Klang's talk at Scala Days 2019<br/>
  https://www.youtube.com/watch?v=5FTJUUoT6y4
  

---

## Scala 2.13 Collection Related Links

- Implementing the Scala 2.13 collections<br/>
  Stefan Zeiger's talk at Scala Days 2019 in Lausanne<br/>
  https://www.youtube.com/watch?v=L1lxZ1LBuGI
  
- The Architecture of Scala 2.13's Collections<br/>
  https://docs.scala-lang.org/overviews/core/architecture-of-scala-213-collections.html

- Migrating a project to Scala 2.13's Collections<br/>
  https://docs.scala-lang.org/overviews/core/collections-migration-213.html

- Scala 2.13 Collection Compatibility Library<br/>
  https://github.com/scala/scala-collection-compat

- Let them be Lazy<br/>
  Julien Richard Foy's blog on the lazy collection (Views and LazyList)<br/>
  https://www.scala-lang.org/blog/2017/11/28/view-based-collections.html

- Scala 2.13's Collections Rework<br/>
  Stefan Zeiger's blog on the collections rework<br/>
  https://www.scala-lang.org/blog/2017/02/28/collections-rework.html

---

class: middle, center

# Thank You
<br/>
<br/>
<br/>

# Q &amp; A
<br/>
<br/>
<br/>
<br/>
<br/>

https://github.com/hermannhueck/new-in-scala213


</textarea>

  <script src="remark-latest.min.js" type="text/javascript">
  </script>
  <script type="text/javascript">
    var slideshow = remark.create({
      // sourceUrl: 'some-source.md',

      // Set the slideshow display ratio
      // Default: '4:3'
      // Alternatives: '16:9', ...
      ratio: '4:3',

      // Navigation options
      navigation: {
        // Enable or disable navigating using scroll
        // Default: true
        // Alternatives: false
        scroll: false,

        // Enable or disable navigation using touch
        // Default: true
        // Alternatives: false
        touch: true,

        // Enable or disable navigation using click
        // Default: false
        // Alternatives: true
        click: false
      },

      // Enable or disable counting of incremental slides in the slide counting
      countIncrementalSlides: true
    });
  </script>
</body>

</html>